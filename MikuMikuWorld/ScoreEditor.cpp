#include "Application.h"
#include "FileDialog.h"
#include "SUS.h"
#include "SusExporter.h"
#include "SusParser.h"
#include "ScoreConverter.h"
#include "UI.h"
#include "Constants.h"
#include <tinyfiledialogs.h>
#include "Utilities.h"

namespace MikuMikuWorld
{
	ScoreEditor::ScoreEditor()
	{
		renderer = std::make_unique<Renderer>();
		context.audio.initAudio();

		exportComment = concat("This file was generated by " APP_NAME, Application::getAppVersion().c_str(), " ");
	}

	void ScoreEditor::update()
	{
		drawMenubar();
		drawToolbar();

		ImGui::Begin(IMGUI_TITLE(ICON_FA_MUSIC, "notes_timeline"), NULL, ImGuiWindowFlags_Static | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse);
		timeline.update(context, edit, renderer.get());
		ImGui::End();

		if (ImGui::Begin(IMGUI_TITLE(ICON_FA_BUG, "debug"), NULL))
		{
			timeline.debug();
		}
		ImGui::End();

		if (ImGui::Begin(IMGUI_TITLE(ICON_FA_ALIGN_LEFT, "chart_properties"), NULL, ImGuiWindowFlags_Static))
		{
			propertiesWindow.update(context);
		}
		ImGui::End();

		if (ImGui::Begin(IMGUI_TITLE(ICON_FA_WRENCH, "settings"), NULL, ImGuiWindowFlags_Static))
		{
			optionsWindow.update(context, edit, timeline.currentMode);
		}
		ImGui::End();

		if (ImGui::Begin(IMGUI_TITLE(ICON_FA_DRAFTING_COMPASS, "presets"), NULL, ImGuiWindowFlags_Static))
		{
			presetsWindow.update(context, presetManager);
		}
		ImGui::End();

		// other windows here
	}

	void ScoreEditor::create()
	{
		context.score = {};
		context.workingData = {};
		context.history.clear();
		context.scoreStats.calculateStats(context.score);
		context.audio.disposeBGM();
	}

	void ScoreEditor::loadScore(std::string filename)
	{
		std::string extension = File::getFileExtension(filename);
		std::transform(extension.begin(), extension.end(), extension.begin(), ::tolower);

		// backup next note ID in case of an import failure
		int nextIdBackup = nextID;
		try
		{
			resetNextID();
			if (extension == SUS_EXTENSION)
			{
				SusParser susParser;
				context.score = ScoreConverter::susToScore(susParser.parse(filename));
				context.workingData.filename = "";
			}
			else if (extension == MMWS_EXTENSION)
			{
				context.score = deserializeScore(filename);
				context.workingData.filename = filename;
			}

			context.workingData.title = context.score.metadata.title;
			context.workingData.designer = context.score.metadata.author;
			context.workingData.artist = context.score.metadata.artist;
			context.workingData.musicOffset = context.score.metadata.musicOffset;
			context.workingData.musicFilename = context.score.metadata.musicFile;
			context.workingData.jacket.load(context.score.metadata.jacketFile);

			context.audio.changeBGM(context.workingData.musicFilename);
			context.audio.setBGMOffset(0, context.workingData.musicOffset);

			context.history.clear();
			context.scoreStats.calculateStats(context.score);
			timeline.calculateMaxOffsetFromScore(context.score);

			UI::setWindowTitle((context.workingData.filename.size() ? File::getFilename(context.workingData.filename) : windowUntitled) + "*");
			context.upToDate = context.workingData.filename.size();
		}
		catch (std::runtime_error& err)
		{
			nextID = nextIdBackup;

			std::string errMsg = "An error occured while reading the score file.\n" + std::string(err.what());
			tinyfd_messageBox(APP_NAME, errMsg.c_str(), "ok", "error", 1);
		}
	}

	void ScoreEditor::open()
	{
		std::string filename;
		if (FileDialog::openFile(filename, FileType::ScoreFile))
			loadScore(filename);
	}

	bool ScoreEditor::trySave(std::string filename)
	{
		try
		{
			if (!filename.size())
				return saveAs();
			else
				return save(filename);
		}
		catch (std::runtime_error& error)
		{
			std::string msg{ "An error occured while trying to save the chart.\n" };
			msg.append(error.what());
			tinyfd_messageBox(APP_NAME, msg.c_str(), "ok", "error", 1);
		}

		return false;
	}

	bool ScoreEditor::save(std::string filename)
	{
		context.score.metadata.title = context.workingData.title;
		context.score.metadata.author = context.workingData.designer;
		context.score.metadata.artist = context.workingData.artist;
		context.score.metadata.musicFile = context.workingData.musicFilename;
		context.score.metadata.musicOffset = context.workingData.musicOffset;
		context.score.metadata.jacketFile = context.workingData.jacket.getFilename();
		serializeScore(context.score, filename);

		UI::setWindowTitle(File::getFilename(filename));
		context.upToDate = true;

		return true;
	}

	bool ScoreEditor::saveAs()
	{
		std::string filename;
		if (FileDialog::saveFile(filename, FileType::MMWSFile))
		{
			context.workingData.filename = filename;
			return save(context.workingData.filename);
		}

		return false;
	}

	void ScoreEditor::exportSus()
	{
		std::string filename;
		if (FileDialog::saveFile(filename, FileType::SUSFile))
		{
			SusExporter exporter;
			SUS sus = ScoreConverter::scoreToSus(context.score);
			exporter.dump(sus, filename, exportComment);
		}
	}

	void ScoreEditor::drawMenubar()
	{
		ImGui::BeginMainMenuBar();
		ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(10, 3));

		if (ImGui::BeginMenu(getString("file")))
		{
			if (ImGui::MenuItem(getString("new")))
			{
				Application::windowState.resetting = true;
			}

			if (ImGui::MenuItem(getString("open")))
			{
				Application::windowState.resetting = true;
				Application::windowState.shouldPickScore = true;
			}

			ImGui::Separator();
			if (ImGui::MenuItem(getString("save")))
				trySave(context.workingData.filename);

			if (ImGui::MenuItem(getString("save_as")))
				saveAs();

			if (ImGui::MenuItem(getString("export")))
				exportSus();

			ImGui::Separator();
			if (ImGui::MenuItem(getString("exit")))
			{
				// set exit state here
			}

			ImGui::EndMenu();
		}

		if (ImGui::BeginMenu(getString("edit")))
		{
			if (ImGui::MenuItem(getString("undo")))
				context.undo();

			if (ImGui::MenuItem(getString("redo")))
				context.redo();

			ImGui::Separator();
			if (ImGui::MenuItem(getString("delete")))
				context.deleteSelection();

			if (ImGui::MenuItem(getString("cut")))
				context.cutSelection();

			if (ImGui::MenuItem(getString("copy")))
				context.copySelection();

			if (ImGui::MenuItem(getString("paste")))
				context.paste(false);

			ImGui::Separator();
			if (ImGui::MenuItem(getString("select_all")))
				context.selectAll();

			ImGui::Separator();
			if (ImGui::MenuItem(getString("settings")))
			{
				// open settings here
			}

			ImGui::EndMenu();
		}

		if (ImGui::BeginMenu(getString("view")))
		{
			ImGui::MenuItem(getString("show_step_outlines"), NULL, &timeline.drawHoldStepOutlines);
			ImGui::MenuItem(getString("playback_auto_scroll"), NULL, &timeline.playbackAutoScroll);

			ImGui::EndMenu();
		}

		if (ImGui::BeginMenu(getString("window")))
		{
			ImGui::EndMenu();
		}

		if (ImGui::BeginMenu(getString("help")))
		{
			ImGui::EndMenu();
		}

		ImGui::PopStyleVar();
		ImGui::EndMainMenuBar();
	}

	void ScoreEditor::drawToolbar()
	{
		ImGuiViewport* viewport = ImGui::GetMainViewport();
		ImVec2 toolbarSize{ viewport->WorkSize.x, UI::toolbarBtnSize.y + ImGui::GetStyle().WindowPadding.y + 5 };

		// keep toolbar on top in main viewport
		ImGui::SetNextWindowViewport(viewport->ID);
		ImGui::SetNextWindowPos(viewport->WorkPos);
		ImGui::SetNextWindowSize(toolbarSize, ImGuiCond_Always);
		ImGui::Begin("##app_toolbar", NULL, ImGuiWindowFlags_Toolbar);

		// make buttons transparent
		ImGui::PushStyleColor(ImGuiCol_Button, ImVec4{ 0.0f, 0.0f, 0.0f, 0.0f });
		
		if (UI::toolbarButton(ICON_FA_FILE, getString("new"), NULL))
		{
			Application::windowState.resetting = true;
		}

		if (UI::toolbarButton(ICON_FA_FOLDER_OPEN, getString("open"), NULL))
		{
			Application::windowState.resetting = true;
			Application::windowState.shouldPickScore = true;
		}

		if (UI::toolbarButton(ICON_FA_SAVE, getString("save"), NULL))
			trySave(context.workingData.filename);

		if (UI::toolbarButton(ICON_FA_FILE_EXPORT, getString("export"), NULL))
			exportSus();

		UI::toolbarSeparator();

		if (UI::toolbarButton(ICON_FA_CUT, getString("cut"), NULL, context.selectedNotes.size() > 0))
			context.cutSelection();

		if (UI::toolbarButton(ICON_FA_COPY, getString("copy"), NULL, context.selectedNotes.size() > 0))
			context.copySelection();

		if (UI::toolbarButton(ICON_FA_PASTE, getString("paste"), NULL))
			context.paste(false);

		UI::toolbarSeparator();

		if (UI::toolbarButton(ICON_FA_UNDO, getString("undo"), NULL, context.history.hasUndo()))
			context.undo();

		if (UI::toolbarButton(ICON_FA_REDO, getString("redo"), NULL, context.history.hasRedo()))
			context.redo();

		UI::toolbarSeparator();

		for (int i = 0; i < TXT_ARR_SZ(timelineModes); ++i)
		{
			if (UI::toolbarImageButton((std::string{"timeline_"} + timelineModes[i]).c_str(), getString(timelineModes[i]), NULL, true, (int)timeline.currentMode == i))
				timeline.currentMode = (TimelineMode)i;
		}

		// add toolbar buttons here

		ImGui::PopStyleColor();
		ImGui::End();
	}
}